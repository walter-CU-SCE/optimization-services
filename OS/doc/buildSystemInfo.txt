Well, Stefan would know better, but as I understand it, theAC_COIN_HAS_PACKAGE command actually first creates *_LIB and *_CFLAGSvariables for the package named in the first argument and then alsoadds those to the *_LIB and *_CFLAGS variables of the library/binarythat depends on the package being defined. So the COINDEPEND_CFLAGSare just the combination of the flags of the individual packages thatmake up CoinDepend. These then get added to XXXLIB_CFLAGS along withany other dependent project identified in later AC_COIN_HAS_PACKAGE toform the full set of flags for XXXLIB. Admittedly, this is a bitconfusing and I'm not sure I got it entirely right. Stefan?



This has nothing to do with how you code as a developer. We aretalking about users, not you, when we talk about what should be in theMakefile for the examples. To a user, all they have to know is thatthey want to link to OS. A user should not have to know that, forinstance, you built without support for Bonmin and Couenne this timebecause they aren't available and so they don't have to put those onthe link line. How would they know that? The .pc file automaticallycontains whatever dependencies were present at the time of thebuilding of the library, no matter what those were. As far asdevelopment goes, nothing changes in the above.> 2.  OS depends, for example, on Cgl. But OS also uses SYMPHONY. In SYMPHONY> you have>> Requires: cgl osi-vol osi-dylp osi-clp coinutils = trunk osi>> so should I skip Cgl?If it is possible for OS to use Cgl *directly*, not *indirectly*because some other project linked to by OS needs it, then it should belisted. But I don't really see how you could use Cgl directly withouthaving some project like Cbc, SYMPHONY, Bonmin, Couenne, etc. present,in which case Cgl would be among the dependencies of *that* project.Is there a use case where you would want to link to Cgl without one ofthe others present?In any case, this is not something you have to decide since thesedependencies are generated automatically based on what projects youcheck for in configure.ac. The checking there works the same way---youonly check for the things that you directly depend on, not thesecondary dependencies. the m4 macros use pkg-config in the same wayas I've been describing to generate the secondary dependencies. Sojust don't worry about what goes in the .pc files underdependencies---it's checks in configure.ac that you have to worryabout. Just eliminate any that you don't need (such as for Cgl?) andthey will not appear in the .pc file either.> Maybe not if the user has not installed SYMPHONY.>  Also, I see you have osi-clp, but NOT clp. I guess based on what you said> about the recursive nature of things this is not necessary since osi-clp has>> Requires: clp osiYes, SYMPHONY can't use Clp except through Osi, so there is no reasonto check for Clp directly. If we had a native interface to Clp thatcould be used if Osi was missing, then Clp could be checked for as adependency. 


From Lou:

> What happened to $(COINUTILSSRCDIR)????	Answer on two levels. First, for the file you were looking at(CoinUtils/test/Makefile.am), it makes sense to give a relative locationfor the headers. If you're building in the test directory, the headersare in ../src. If you're doing a VPATH build, you need to know where thesource directory is, then a relative path, hence $(srcdir)/../src. Therule to remember is that srcdir is the source for the directory you'rebuilding. When you're building the test directory, srcdir resolves tothe source for test.	More generally, what happened to COINUTILSSRCDIR? A short but somewhatmisleading answer would be `It's been replaced by COINUTILS_CFLAGS'. Buta longer answer may give you a better perspective.	It's been replaced by pkg-config, and a whole bunch of buildtoolsmacros that query pkg-config and deal with the situation when pkg-configisn't available (I'll let Stefan speak to that). If you want to know theheader directories for CoinUtils, you ask  pkg-config --cflags coinutilsand pkg-config consults coinutils.pc to give the answer (correct for myparticular configuration)-I/devel/Coin/Split-FedGCC64/include/coin-I/devel/Coin/Split-FedGCC64/include/coin/ThirdPartyThese are the places to look for the installed headers for CoinUtils andGlpk in my local build structure. Notice that pkg-config is helping mehere, keeping track of the fact that my CoinUtils build brings in glpk.To get the libs needed to link against libCoinUtils,  pkg-config --libs coinutilsgives -L/devel/Coin/Split-FedGCC64/lib/coin   -L/devel/Coin/Split-FedGCC64/lib/coin/ThirdParty -lCoinUtils -lbz2  -llapack -lblas -lm -lcoinglpk -ldl -lgmp -lzSo you can see why this simplifies things in the makefiles. When you'rebuilding against uninstalled packages pkg-config needs to findcoinutils-uninstalled.pc. Again, the buildtools macros take care ofthis, manipulating PKG_CONFIG_PATH so that pkg-config can find theright .pc file.You can ask for information about more than one package, e.g.,  pkg-config --cflags coinutils osi cgland you'll get the combined information for all, duplicates removed:  -I/devel/Coin/Split-FedGCC64/include/coin   -I/devel/Coin/Split-FedGCC64/include/coin/ThirdParty  If you're saying `but that's exactly the same as the previous answer',you're exactly right. All the installed header files are in one place.You don't get the same information repeated three times (for CoinUtils,Osi, and Cgl). So when configure.ac usesAC_COIN_HAS_PACKAGE(CoinDepend, [cgl osi coinutils = trunk], [CbcLibCbcGeneric])what will happen is that buildtools creates a variable,COINDEPEND_CFLAGS, and this is set to the output of  pkg-config --cflags cgl osi coinutils(with some fussing to make sure it's the trunk of coinutils).COINDEPEND_CFLAGS will be added to command lines when building CbcLiband CbcGeneric.	Hope this helps. There's nothing quite so frustrating as findingyourself afloat in an unfamiliar sea.


%%%%%%%%%%%

export  PKG_CONFIG_PATH=/Users/kmartin/coin/os-tmp/vpath-debug/lib/pkgconfig 