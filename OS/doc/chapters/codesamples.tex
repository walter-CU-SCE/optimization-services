\section{Code samples to illustrate the OS Project}\label{section:examples}

These example executable files are not built by running {\tt configure} and {\tt make}.  In order to build the examples
in a unix environment the user must first run
%
\index{make install@{\tt make install}}
\begin{verbatim}
make install
\end{verbatim}
in the COIN-OS project root directory (the discussion in this section assumes that the project root directory is
{\tt COIN-OS}).  Running {\tt make install}  will  place all the header files required by the examples in the directory
\begin{verbatim}
COIN-OS/include
\end{verbatim}
and all of the libraries required by the examples in the directory
\begin{verbatim}
COIN-OS/lib
\end{verbatim}
The source code for the examples is in the directory {\tt COIN-OS/OS/examples}.  For instance, the {\tt osModDemo}
example is in the directory
\begin{verbatim}
COIN-OS/OS/examples/osModDemo
\end{verbatim}
Next, the user should connect to the appropriate example directory and run {\tt make}.
If the user has done a VPATH\index{VPATH} build, the makefiles\index{makefile|(} will be in each respective example directory under
\begin{verbatim}
vpath_root/OS/examples
\end{verbatim}
otherwise, the makefiles will be in each respective example directory under
\begin{verbatim}
COIN-OS/OS/examples
\end{verbatim}

The {\tt Makefile} in each example directory is fairly simple and is designed to be easily modified by the user
if necessary.  The part of the Makefile to be adjusted, if necessary, is

\begin{verbatim}
##########################################################################
#    You can modify this example makefile to fit for your own program.   #
#    Usually, you only need to change the five CHANGEME entries below.   #
##########################################################################

# CHANGEME: This should be the name of your executable
EXE = OSModDemo
# CHANGEME: Here is the name of all object files corresponding to the source
#           code that you wrote in order to define the problem statement
OBJS =  OSModDemo.o
# CHANGEME: Additional libraries
ADDLIBS =
# CHANGEME: Additional flags for compilation (e.g., include flags)
ADDINCFLAGS =  -I${prefix}/include
# CHANGEME: SRCDIR is the path to the source code; VPATH is the path to
# the executable. It is assumed # that the lib directory is in prefix/lib
# and the header files are inprefix/include
SRCDIR = /Users/kmartin/Documents/files/code/cpp/OScpp/COIN-OS/OS/examples/osModDemo
VPATH = /Users/kmartin/Documents/files/code/cpp/OScpp/COIN-OS/OS/examples/osModDemo
prefix = /Users/kmartin/Documents/files/code/cpp/OScpp/vpath
\end{verbatim}


Developers can use the Makefiles as a starting point for building applications that use the 
OS project libraries\index{makefile|)}.

\medskip
Users of Microsoft Visual Studio can obtain the executables by opening the solution file 
{\tt OS.sln}\index{OS sln@{\tt OS.sln}} in
Visual Studio (or by double-clicking on the file in Windows Explorer). Once the file is opened, 
select the Configuration Manager from the Build menu and select the projects you desire to be built. 
Then select Build Solution from the Build menu (or press F7). 

The executables are also part of the binary distribution described in Section~\ref{section:vsexamples}.


\subsection{Algorithmic Differentiation:  Using the OS Algorithmic Differentiation Methods}\label{section:cppad}

\index{Algorithmic differentiation|(}
In the {\tt OS/examples/algorithmicDiff} folder is test code {\tt OSAlgorithmicDiffTest.cpp}. This code
illustrates the key methods in the {\tt OSInstance}\index{OSInstance@{\tt OSInstance}} API that are used for
algorithmic differentiation.   These methods are described in Section~\ref{section:ad}.



\subsection{Instance Generator: Using the OSInstance API to Generate Instances}\label{section:exampleOSInstanceGeneration}

This example is found in the {\tt instanceGenerator} folder in the {\tt examples} folder. This example illustrates
how to build a complete in-memory model instance using the {\tt OSInstance}\index{OSInstance@{\tt OSInstance}} API.
See the code {\tt OSInstanceGenerator.cpp} for the complete example. Here we provide a few highlights to illustrate
the power of the API.

The first step is to create an {\tt OSInstance} object.
\begin{verbatim}
OSInstance *osinstance;
osinstance = new OSInstance();
\end{verbatim}

The instance has two variables, $x_{0}$ and $x_{1}$. Variable $x_{0}$ is a continuous variable with lower bound of $-100$ and upper bound of $100$. Variable $x_{1}$ is a binary variable. First declare the instance to have two variables.
\begin{verbatim}
osinstance->setVariableNumber( 2);
\end{verbatim}
Next, add each variable. There is an {\tt addVariable} method with the signature
\begin{verbatim}
addVariable(int index, string name, double lowerBound, double upperBound, char type);
\end{verbatim}
Then the calls for these two variables are
\begin{verbatim}
osinstance->addVariable(0, "x0", -100, 100, 'C');
osinstance->addVariable(1, "x1", 0, 1, 'B');
\end{verbatim}
There is also a method {\tt setVariables} for adding more than one variable simultaneously.  The objective function(s) and constraints are added through similar calls.

Nonlinear terms are also easily added.  The following code illustrates how to add a nonlinear term
$x_{0}*x_{1}$ in the {\tt <nonlinearExpressions>} section of  OSiL. This term is part of constraint~1
and is the second of six constraints contained in the instance.
\begin{verbatim}
osinstance->instanceData->nonlinearExpressions->numberOfNonlinearExpressions = 6;
osinstance->instanceData->nonlinearExpressions->nl = new Nl*[ 6 ];
osinstance->instanceData->nonlinearExpressions->nl[ 1] = new Nl();
osinstance->instanceData->nonlinearExpressions->nl[ 1]->idx = 1;
osinstance->instanceData->nonlinearExpressions->nl[ 1]->osExpressionTree =
new OSExpressionTree();
// the nonlinear expression is stored as a vector of nodes in postfix format
// create a variable nl node for x0
nlNodeVariablePoint = new OSnLNodeVariable();
nlNodeVariablePoint->idx=0;
nlNodeVec.push_back( nlNodeVariablePoint);
// create the nl node for x1
nlNodeVariablePoint = new OSnLNodeVariable();
nlNodeVariablePoint->idx=1;
nlNodeVec.push_back( nlNodeVariablePoint);
// create the nl node for *
nlNodePoint = new OSnLNodeTimes();
nlNodeVec.push_back( nlNodePoint);
// now the expression tree
osinstance->instanceData->nonlinearExpressions->nl[ 1]->osExpressionTree->m_treeRoot =
nlNodeVec[ 0]->createExpressionTreeFromPostfix( nlNodeVec);
\end{verbatim}
\index{Algorithmic differentiation|)}

%\subsection{Excel:  Using VBA To Generate OSiL}\label{section:exampleExcel}

%\subsection{Matlab:  Using  MATLAB To Generate OSiL}\label{section:exampleMatlab}

\subsection{branchCutPrice:  Using Bcp}\label{section:examplebranchCutPrice}

This example illustrates the use of the COIN-OR Bcp (Branch-cut-and-price) project.  
This project offers the user with the ability to have control over each node in the branch and process. 
This makes it possible to add user-defined cuts and/or user-defined variables. At each node in the tree, 
a call is made to the method {\tt process\_lp\_result()}. In the example problem we illustrate 1) adding COIN-OR Cgl cuts, 
2) a user-defined cut, and 3) a user-defined variable. 


\subsection{OSModificationDemo: Modifying an In-Memory {\tt OSInstance} Object}\label{section:exampleOSModDemo}

The {\tt osModificationDemo} folder holds the file {\tt OSModificationDemo.cpp}.
This is similar to the {\tt instanceGenerator} example. In this case, a simple
linear program is generated. However, this example also illustrates how to
modify an in-memory OSInstance object. In particular, we illustrate how to
modify an objective function coeffient. Note the dual occurrence of the
following code

\begin{verbatim}
solver->osinstance->bObjectivesModified = true;
\end{verbatim}

in the {\tt OSModificationDemo.cpp} file (lines 177 and 187).
This line is critical, since otherwise changes made to the OSInstance object
will not be passed to the solver.

This example also illustrates calling a COIN-OR solver,
in this case {\tt Clp}\index{COIN-OR projects!Clp@{\tt Clp}}.

\vskip 8pt

{\bf Important:} the ability to modify a problem instance is still extremely limited in this release.
A better API for problem modification will come with a later release of OS.



\subsection{OSSolverDemo: Building In-Memory Solver and Option Objects}\label{section:exampleOSSolverDemo}

The code in the  example file {\tt OSSolverDemo.cpp} in the folder {\tt osSolverDemo}  illustrates  how to build solver interfaces and  an in-memory {\tt OSOption} object. In this example we  illustrate building a solver interface and corresponding {\tt OSOption} object for the solvers {\tt Clp}, {\tt Cbc}, {\tt SYMPHONY}, {\tt Ipopt},   {\tt Bonmin}, and {\tt Couenne}.   Each solver class inherits from a virtual {\tt OSDefaultSolver} class. Each solver class has the string data members

\begin{itemize}
\item {\tt osil --} this string conforms to the OSiL standard and holds the model instance.

\item {\tt osol --} this string conforms to the OSoL standard and holds an instance with the 
solver options (if there are any); this string can be empty.

\item {\tt osrl --} this string conforms to the OSrL standard and holds the solution instance; 
each solver interface produces an osrl string.
\end{itemize}

Corresponding to each string there is an in-memory object data member, namely

\begin{itemize}
\item {\tt osinstance --}  an in-memory {\tt OSInstance} object containing the model instance
and get() and set() methods to access various parts of the model.


\item {\tt osoption --} an in-memory {\tt OSOption} object; solver options can be accessed or 
set using get() and set() methods.


\item {\tt osresult --}  an in-memory {\tt OSResult} object; various parts of the model solution  
are accessible through get() and set() methods.
\end{itemize}


For each solver we detail five steps:

\begin{itemize}
\item[Step 1:]  Read a model instance from a file  and create the corresponding {\tt OSInstance} object.
For four of the solvers we read a file with the model instance in OSiL format. For the Clp example 
we read an MPS file and convert to OSiL. For the Couenne example we read an AMPL nl file and convert 
to OSiL.

\item[Step 2:]  Create an {\tt OSOption} object and set options appropriate for the given solver.   
This is done by defining

\begin{verbatim}
OSOption* osoption = NULL;
osoption = new OSOption();
\end{verbatim}

A key method in the {\tt OSOption} interface is {\tt setAnotherSolverOption()}.  This method 
takes the following arguments in order.

\begin{itemize}
\item[] {\tt std::string name} -- the option name;
\item[] {\tt std::string value}  -- the value of the option;
\item[] {\tt std::string solver} -- the name of the solver to which the option applies;
\item[] {\tt std::string category} -- options may fall into categories. For example, consider the  
Couenne solver.  This solver is also linked to the Ipopt and Bonmin solvers and  it is possible 
to set options for these solvers through the Couenne API. In order to set an Ipopt option 
you would set the {\tt solver} argument to {\tt couenne} and set the {\tt category} option 
to {\tt ipopt}.

\item[] {\tt std::string type} -- many solvers require knowledge of the data type, so you can set 
the type to {\tt double}, {\tt integer}, {\tt boolean} or {\tt string}, depending on the solver 
requirements. Special types defined by the solver, such as the type {\tt numeric} used by the
Ipopt solver, can also be accommodated. It is the user's responsibility to verify the type
expected by the solver.


\item[] {\tt std::string  description} -- this argument is used to provide any detail or 
additional information about the option. An empty string ({\tt""}) can be passed if such additional
information is not needed.
\end{itemize}

For excellent documentation that details solver options for Bonmin, Cbc, and Ipopt  we recommend 

\begin{center}
\url{http://www.coin-or.org/GAMSlinks/gamscoin.pdf}
\end{center}


\item[Step 3:] Create the solver object. In the OS project there is a {\it virtual} solver that 
is declared by

\begin{verbatim}
DefaultSolver *solver  = NULL;
\end{verbatim}

The Cbc, Clp and SYMPHONY solvers as well as other solvers of linear and integer linear programs
are all invoked by creating a {\tt CoinSolver().} For example, the following is used to invoke Cbc.

\begin{verbatim}
solver = new CoinSolver();
solver->sSolverName ="cbc";
\end{verbatim}

%Then to declare a specific, for example, an {\tt Ipopt} solver, simply write
Other solvers, particularly Ipopt, Bonmin and Couenne are implemented separately. So to declare,
for example, an Ipopt solver, one should write

\begin{verbatim}
solver = new IpoptSolver();
\end{verbatim}

The syntax is the same regardless of solver. 

\item[Step 4:] Import the {\tt OSOption} and {\tt OSInstance} into the solver and solve the model. 
This process is identical regardless of which solver is used. The syntax is:

\begin{verbatim}
solver->osinstance = osinstance;
solver->osoption = osoption;	
solver->solve();
\end{verbatim}

\item[Step 5:] After optimizing the instance,  each of the OS solver interfaces uses the underlying solver API to get the solution result and write the result to a string 
named {\tt osrl} which is a string representing the solution instance in the {\tt OSrL} XML standard.  
This string is accessed by

\begin{verbatim}
solver->osrl
\end{verbatim}


In the example code {\tt OSSolverDemo.cpp} we have written a method,  

\begin{verbatim}
void getOSResult(std::string osrl)
\end{verbatim}

that takes the {\tt osrl} string and creates an {\tt OSResult} object.   
We then illustrate several of the {\tt OSResult} API methods 

\begin{verbatim}
double getOptimalObjValue(int objIdx, int solIdx);
std::vector<IndexValuePair*>  getOptimalPrimalVariableValues(int solIdx);
\end{verbatim}
to get and write out the optimal objective function value, and optimal primal values.  See also Section \ref{section:exampleOSResultDemo}.

\end{itemize}

We now highlight some of the features illustrated by each of the solver examples.

\begin{itemize}
\item {\bf Clp --}  In this example we read in a problem instance in MPS format.  The class 
{\tt OSmps2osil}  has a method {\tt mps2osil} that is used to convert the MPS instance contained 
in a file into an in-memory {\tt OSInstance} object. This example also illustrates how to 
set options using the Osi interface. In particular we turn on intermediate output which is 
turned off by default in the Coin Solver Interface. 

\item {\bf Cbc --}  In this example we read a problem instance that is in OSiL format and create 
an in-memory {\tt OSInstance} object.  We then create an {\tt OSOption} object.  This is quite trivial.  
A  plain-text XML file conforming to the OSiL schema is read into a string {\tt osil} which is then 
converted into the in-memory {\tt OSInstance} object by

\begin{verbatim}
OSiLReader *osilreader = NULL;
OSInstance *osinstance = NULL;
osilreader = new OSiLReader(); 
osinstance = osilreader->readOSiL( osil);
\end{verbatim}


 We set the linear programming algorithm to be the primal simplex method and then set the option 
on the pivot selection to be Dantzig rule.  Finally, we set the print level to be 10.

\item {\bf SYMPHONY --}   In this example we also read a problem instance that is in OSiL format and 
create an in-memory {\tt OSInstance} object.  We then create an {\tt OSOption} object and 
illustrate setting the {\tt verbosity} option.

\item {\bf Ipopt --}   In this example we also read a problem instance that is in OSiL format.  
However, in this case we do  not create an {\tt OSInstance} object. We read the OSiL file into 
a string {\tt osil}.  We then feed the {\tt osil} string directly into the Ipopt solver by
\begin{verbatim}
solver->osil = osil;
\end{verbatim} 
The user always has the option of providing the OSiL to the solver as either a string or in-memory object.

Next we create an {\tt OSOption} object. For Ipopt, we illustrate setting the maximum iteration limit 
and also provide the name of the output file. In addition, the OSOption object can hold initial solution 
values. We illustrate how to initialize all of the variable to 1.0.

\begin{verbatim}
numVar = 2; //rosenbrock mod has two variables 
xinitial = new double[numVar];
for(i = 0; i < numVar; i++){
    xinitial[ i] = 1.0;
}
osoption->setInitVarValuesDense(numVar, xinitial);
\end{verbatim}



\item {\bf Bonmin --}  In this example we read a problem instance that is in OSiL format and create 
an in-memory {\tt OSInstance} object just as was done in the Cbc and SYMPHONY examples.   
We then create an {\tt OSOption} object.  In setting the  {\tt OSOption} object we intentionally 
set an option that will cause the Bonmin solver to terminate early.  In particular we set the 
{\tt node\_limit} to zero. 

\begin{verbatim}
osoption->setAnotherSolverOption("node_limit","0","bonmin","","integer","");
\end{verbatim}

This results in early termination of the algorithm. The {\tt OSResult} class API has a method
\begin{verbatim}
std::string getSolutionStatusDescription(int solIdx);
\end{verbatim}

For this example, invoking
\begin{verbatim}
osresult->getSolutionStatusDescription( 0)
\end{verbatim}
gives the result:
\begin{verbatim}
LIMIT_EXCEEDED[BONMIN]: A resource limit was exceeded, we provide the current solution.
\end{verbatim}


\item {\bf Couenne --}   In this example we read in a problem instance in AMPL nl format.  
The class {\tt OSnl2osil}  has a method {\tt nl2osil} that is used to convert the nl instance 
contained in a file into an in-memory {\tt OSInstance} object. This is done as follows:

\begin{verbatim}
// convert to the OS native format
OSnl2osil *nl2osil = NULL;
nl2osil = new OSnl2osil( nlFileName);
// create the first in-memory OSInstance
nl2osil->createOSInstance() ;
osinstance =  nl2osil->osinstance;
\end{verbatim}
\end{itemize}

This part of the example also illustrates setting options in one solver from another. 
Couenne uses Bonmin which uses Ipopt.  So for example,

\begin{verbatim}
osoption->setAnotherSolverOption("max_iter","100","couenne","ipopt","integer","");
\end{verbatim}
identifies the solver as {\tt couenne}, but the category of value of {\tt ipopt}  tells the solver 
interface to set the iteration limit on the Ipopt algorithm that is solving the continuous relaxation 
of the problem.  Likewise, the setting
\begin{verbatim}
osoption->setAnotherSolverOption("num_resolve_at_node","3","couenne","bonmin","integer","");
\end{verbatim}
identifies the solver as {\tt couenne}, but the category of value of {\tt bonmin}  tells the solver 
interface to tell the Bonmin solver to try three starting points at each node. 

 

\subsection{OSResultDemo: Building In-Memory Result Object to Display Solver Result}\label{section:exampleOSResultDemo}

The OS protocol for representing an optimization result is {\tt OSrL}. Like the {\tt OSiL} and {\tt OSoL} protocol, this protocol has an associated in-memory {\tt OSResult} class with corresponding API.  The use of the API is demonstrated in the code {\tt OSResultDemo.cpp} in the folder {\tt OS/examples/OSResultDemo}.  In the code we solve a linear program with the {\tt Clp} solver.  The OS solver interface builds an {\tt OSrL} string that we read into the {\tt OSrLReader} class and create and {\tt OSResult} object. We then use the {\tt OSResult} API to get the optimal primal and dual solution. We also use the API to get the reduced cost values. 


\subsection{OSCglCuts: Using the OSInstance API to Generate Cutting Planes}\label{section:exampleOSAddCuts}

In this example, we show how to add cuts to tighten an LP using COIN-OR
{\tt Cgl} (Cut Generation Library)\index{COIN-OR projects!Cgl@{\tt Cgl}}.
A file ({\tt p0033.osil}) in OSiL format is used to create an OSInstance object. The linear programming relaxation
is solved. Then, Gomory, simple rounding, and knapsack cuts are added using {\tt Cgl}.  The model is then optimized
using {\tt Cbc}.

\subsection{OSRemoteTest:  Calling a Remote Server}\label{section:exampleOSRemoteTest}

This example illustrates the API for the six service methods described in Section~\ref{section:servicemethods}.
The file {\tt osRemoteTest.cpp} in folder {\tt osRemoteTest} first builds a small linear
example, solves it remotely in synchronous mode and displays the solution.
The asynchronous mode is also tested by submitting the problem to a remote solver,
checking the status and either retrieving the answer or killing the process if it has not
yet finished.

{\bf Windows users should note}
that this project links to {\tt wsock32.lib}, which is not part of the Visual Studio  Express Package.  It is necessary
to also download and install the Windows Platform SDK\index{Windows Platform SDK}, which can be found at

\medskip
\noindent{\scriptsize\tt\UrlSdk}. 
\medskip
\noindent See also Section~\ref{section:msvs}.


\subsection{OSJavaInstanceDemo:  Building an OSiL Instance in
Java}\label{section:exampleOSJavaDemo}
\index{Java|(}

In this example we demonstrate how to build an OSiL instance using the Java
OSInstance API.  The example code also  illustrates calling the {\tt
OSSolverService} executable from Java. In order to use this example, the user should do an svn
checkout:

\begin{verbatim}
svn co https://projects.coin-or.org/svn/OS/branches/OSjava OSjava
\end{verbatim}

The {\tt OSjava} folder contains the file {\tt INSTALL.txt}. Please follow the
instructions in {\tt  INSTALL.txt} under the heading:
\begin{verbatim}
== Install Without a Web Server==
\end{verbatim}

These instructions assume that the user has installed the Eclipse IDE. See
\url{http://www.eclipse.org/downloads/}. At this link we recommend that the 
user get {\tt Eclipse Classic}.  In addition, the user should also have a copy of the
{\tt OSSolverService} executable that is compatible with his or her platform.
The {\tt OSSolverService} executable for several different platforms is
available at \url{http://www.coin-or.org/download/binary/OS/OSSolverService/}. 
The user can also build the executable as described in this Manual.  See Section
\ref{section:build}. The code base for this example is in the folder:
\begin{verbatim}
OSjava/OSJavaExamples/src/OSJavaInstanceDemo.java
\end{verbatim}
The code in the file {\tt OSJavaInstanceDemo.java} demonstrates how the
Java OSInstance API that is in {\tt OSCommon} can be used to generate a linear
program and then call the C++ {\tt OSSolverService} executable 
to solve the problem.\index{Java|)}  Running this example in Eclipse will
generate in the folder
\begin{verbatim}
OSjava/OSJavaExamples
\end{verbatim}
two files. It will generate {\tt parincLinear.osil} which is a linear program in
the OS OSiL format, it will also call the {\tt OSSolverService} executable which
generates the result file {\tt result.osrl} in the OS OSrL format. 


\subsection{Using Dip (Decomposition In Integer Progamming)}

	Important Note -- this example assumes you have downloaded the {\tt CoinAll }binary.

We follow the notation of Galati and Ralphs. The integer program of interest is:

\begin{eqnarray}
z_{IP} &=&  \min  \{c^{\top} x \, | \, A^{\prime} x \ge b^{\prime},  \,\, 
A^{\prime \prime} x \ge b^{\prime \prime}, \, \, x \in \mathbb{Z}^{n}  \}
\end{eqnarray}
The problem is divided into two constraint sets $A^{\prime} x \ge b^{\prime}$
which we refer to as the relaxed, coupling, or block constraints and the core
constraints $A^{\prime \prime} x \ge b^{\prime \prime}.$  We then define the
following polyhedron based on the relaxed constraints.
\begin{eqnarray}
{\cal P} &=&  {\rm conv} ( \{ x \in \mathbb{Z}^{n} \, | \, A^{\prime} x \ge
b^{\prime}
\})
\end{eqnarray}
 The LP relaxation of the origianl problem is:
\begin{eqnarray}
z_{LP} &=&  \min  \{c^{\top} x \, | \, A^{\prime} x \ge b^{\prime},  \,\, 
A^{\prime \prime} x \ge b^{\prime \prime}, \, \, x \in \mathbb{R}^{n}  \}
\end{eqnarray}
Ideally,  the constraints $A^{\prime} x \ge b^{\prime}$
should be selected so that solving $Z_{D}$ is an easy {\it hard problem} and
provides better bounds than $Z_{LP}.$
\begin{eqnarray}
z_{D} &=&  \min  \{c^{\top} x \, | \, A^{\prime} x \ge b^{\prime},  \,\, 
x \in {\cal P}, \, \, x \in \mathbb{R}^{n}  \}
\end{eqnarray}


A generic block-angular decomposition algorithm is now available. It is 
based on the Decomposition in Integer Programming (Dip) project jointly with the Optimization Services (OS) project. 
We call this the OS Dip solver.  It has the following features:

\begin{itemize}
\item[1.]  All subproblems are solved via an oracle; either the default oracle
contained in our distribution or one provided by the user.

\item[2.] The OS Dip Solver code is independent of the oracle used to optimize
the subproblems.

\item[3.] Variables are assigned to blocks using an OS option file, the block
definition and  assignment of variables to these blocks has no effect on the OS
Dip Solver code.

\item[4.] Different blocks can be assigned different solver oracles based on the
option values given in the OSoL file. 

\item[5.] There is a default oracle implemented (called OSDipBockCoinSolver)
that currently uses Cbc.

\item[6.] Users can add their own oracles without altering the OS Dip Solver
code. This is done via polymorphic factories. The user creates a separate file containing
the oracle class. The user-provided Oracle class  inherits from the generic
OSDipBlockSolver class. The user need only: 1) add the object file name for the
new oracle to the Makefile, and 2) add the necessary line to
OSDipFactoryInitializer.h indicating that the new oracle is present. 

\end{itemize}

In particular, the  implementation of the OS Dip solver provides a virtual class
{\tt OSDipBlockSolver} with a pure virtual function {\tt solve()}.  The user is
expected to provide a class that inherits from {\tt OSDipBlockSolver} and
implements the method {\tt solve()}.  The {\tt solve()} method should optimize a
linear objective function over ${\cal P}.$ More details are provided in Section
\ref{section:osdipsolver}. The implementation is such  that the user only has to
provide a class with a solve method. The user does not have to edit or alter 
any of the OS Dip Solver code.
By using polymorphic factories the actual solver details are hidden from the OS
Solver.  A default solver, {\tt OSDipBlockCoinSolver}, is provided. This default
solver takes no advantage of special structure and simply calls COIN-OR {bf
Cbc.}
 

\subsubsection{Building and Testing the OS-Dip Example}\label{section:build}

Currently, the Decomposition in Integer Programming ({\bf Dip}) package is not a
dependency of the Optimization Services ({\bf OS}) package -- {\bf Dip} is not
included in the {\bf OS} Externals file. In order to run the OS Dip solver it is
necessary to download both the {\bf OS} and {\bf  Dip} projects. Download order is irrelevant. 
In the discussion that follows we assume that for both 
{\bf OS} and {\bf Dip} the user has successfully completed a {\tt
configure}, {\tt make}, and {\tt make install}. We also assume
that the user is working with the trunk version of both {\bf OS} and {\bf Dip.}


The OS Dip solver C++ code is contained in {\tt TemplateApplication/osDip}.
 The {\tt configure}  will create a {\tt Makefile}  in the {\tt
 TemplateApplication/osDip} folder. The {\tt Makefile} must be edited to reflect
 the location of the {\bf Dip} project. The {\tt Makefile} contains the
 line

\begin{verbatim}
DIPPATH = /Users/kmartin/coin/dip-trunk/vpath-debug/
\end{verbatim}

This setting assumes that there is a {\bf lib} directory:

\begin{verbatim}
/Users/kmartin/coin/dip-trunk/vpath-debug/lib
\end{verbatim}
with the {\bf Dip} library that results from {\tt make install} and an {\tt
include} directory
\begin{verbatim}
/Users/kmartin/coin/dip-trunk/vpath/include
\end{verbatim}
with the {\bf Dip} header files generated by {\tt make install}.  The user
should adjust
\begin{verbatim}
/Users/kmartin/coin/dip-trunk/vpath/
\end{verbatim}
to a path containing the {\bf Dip} {\tt lib} and {\tt include} directories. 
After building the executable by executing the {\tt make} command run the {\tt osdip} application using the command:

\begin{verbatim}
./osdip --param osdip.parm
\end{verbatim}

This should produce the following output.


\begin{verbatim}
FINISH SOLVE
Status= 0 BestLB= 16.00000   BestUB= 16.00000   Nodes= 1      
SetupCPU= 0.01 SolveCPU= 0.10 TotalCPU= 0.11 SetupReal= 0.08 
SetupReal= 0.12 TotalReal= 0.16
Optimal Solution
-------------------------
Quality = 16.00
0      1.00
1      1.00
12     1.00
13     1.00
14     1.00
15     1.00
17     1.00

\end{verbatim}

If you see this output, life is good and things are working. If this doesn't
work, I almost certainly did something stupid and forget to fix it.  The file
{\tt osdip.parm} is a parameter file. The use of the parameter file is 
explained in Section \ref{section:paramaterfile}.


\subsubsection{The OS Dip Solver -- Code Description and
Key Classes}\label{section:osdipsolver}

The OS Dip Solver uses {\bf Dip} to implement a Dantzig-Wofe decomposition
algorithm for block-angular integer programs. Here are some key classes.




\vskip 8pt
\noindent {\bf OSDipBlockSolver:}  This is a virtual class with a pure virtual
function: 

\begin{verbatim}
void solve(double *cost, std::vector<IndexValuePair*> *solIndexValPair,
double *optVal)
\end{verbatim}



\vskip 8pt
\noindent {\bf OSDipBlockSolverFactory:}  This is also virtual class with a pure
virtual function: 

\begin{verbatim}
OSDipBlockSolver* create()
\end{verbatim}

This class also has the static method

\begin{verbatim}
OSDipBlockSolver* createOSDipBlockSolver(const string &solverName)
\end{verbatim}

and a map

\begin{verbatim}
std::map<std::string, OSDipBlockSolverFactory*> factories;
\end{verbatim}


\vskip 8pt
\noindent {\bf Factory:}  This class inherits from the class {\bf
OSDipBlockSolverFactory}. Every sover class that inherits from the  {\bf
OSDipBlockSolver} class should have a {\bf Factory} class memember and since
this {\bf Factory} class member inherits from the {\bf
OSDipBlockSolverFactory} class it should implement a {\tt create()} method that
creates an optject in the class inheriting from {\bf
OSDipBlockSolver}.

\vskip 8pt
\noindent {\bf OSDipFactoryInitializer:}  This class initializes the static map

\begin{verbatim}
OSDipBlockSolverFactory::factories
\end{verbatim}
in the {\bf OSDipBlockSolverFactory} class. 

\vskip 8pt
\noindent {\bf OSDipApp:}  This class inherits from the {\bf Dip} class {\bf
DecompApp}. In {\bf OSDipApp} we implement methods for creating the core
(coupling) constraints, i.e. the constraints $A^{\prime \prime} x \ge
b^{\prime \prime}$.  This is done by implementing the  {\tt createModels()}
method. Regardless, of the problem none of the relaxed or block constraints in $A^{\prime } x \ge
b^{\prime}$ are created. These are treated implicitly in the solver class that
inherits from the class {\bf OSDipBlockSolver.}  This class also implemnts a
method that defines the variables that appear only in the blocks ({\bf
createModelMasterOnlys2}), and a method for generating an initial master (the
method {\bf generateInitVars()  }). 

Since the constraints $A^{\prime } x \ge
b^{\prime}$ are treated explicitly by the Dip solver the {\tt solveRelaxed()}
method must be implemented. In our implementation we have the {\bf OSDipApp} class data
member:
\begin{verbatim}
std::vector<OSDipBlockSolver* > m_osDipBlockSolver;
\end{verbatim}
when the {\tt solveRelaxed()} method is called for block {\tt whichBlock} in
turn we make the call
\begin{verbatim}
m_osDipBlockSolver[whichBlock]->solve(cost, &solIndexValPair, &varRedCost);
\end{verbatim}
and the appropriated solver in class {\bf OSDipBlockSolver} is called. Finally,
the {\bf OSDipApp} class also  initiates the reading of the OS option and
instance files. How these files are used is discussed in Section \ref{section:defineinstance}. 
Based on option input
data this class also creates the appropriate solver object for each block, i.e.
it populates the {\tt  m\_osDipBlockSolver} vector.

\vskip 8pt
\noindent {\bf OSDipInterface:} This class is used  as an interface between the
{\bf OSDipApp} class and classes in the {\bf OS} library. This provides a number
of get methods to provide information to {\bf OSDipApp} such as the coefficients
in the $A^{\prime \prime}$ matrix, objective function coefficients, number of
blocks etc. The {\bf OSDipInterface} class reads the input OSiL and OSoL files
and creates in-memory data structures based on these files. 


  
\vskip 8pt
\noindent {\bf OSDipBlockCoinSolver:}  This class inherits from the {\bf
OSDipBlockSolver} class. It is meant to illustrate how to create a solver class.
This class solves each block by calling {\bf Cbc}.  Use of this class provides a
generic black angular decomposition algorithm.



\vskip 8pt
There is also  {\bf OSDip\_Main.cpp:} which has the {\tt main()} routine and is
the entry point for the executable. It first creates a new price-branch-and-cut
decomposition algorithm and then an Alps solver for which the {\tt solve()}
method is called. 


\subsubsection{User Requirements}\label{section:userreq}


The {\bf OSDipBlockCoinSolver} class provides a solve method for optimizing a
linear objective function over ${\cal P}$ given a linear objective function.
However, this takes no advantage of the special structure available in the
blocks. Therefore, the user may wish to implement his or her own solver class.
In this case the user is required to do the following:
 
 \begin{itemize}
   
   \item[1.] implement a class that inherits from the {\bf OSDipBlockSolver}
   class and implements the solve method,
   
   \item[2.] implement a class {\bf Factory} that inherits from the class {\bf
OSDipBlockSolverFactory} and implements the {\tt create()} method,

	\item[3.] edit the file {\bf OSDipFactoryInitializer.h} and add a line:
	
	\begin{verbatim}
	OSDipBlockSolverFactory::factories["MyBlockSolver"] = new
	MyBlockSolver::Factory;
	\end{verbatim}
   
   \item[4.] alter the Makefile to include the new source code.
 \end{itemize}
 
 \vskip 8pt
 
 {\bf Important -- Directory Structure:} In order to keep things clean, there is
 a directory {\bf solvers} in the {\bf osDip} folder. We suggest using the {\bf
 solvers} directory for all of the solvers that inherit from {\bf
 OSDipBlockSolver}.
 
 \subsubsection{Simple Plant/Lockbox Location Example}


 The problem minimizing
the sum of the cost of capital due to float  and the cost of operating the lock boxes is the
 problem.  

\noindent {\bf Parameters:}
\begin{itemize}
\item[]  $m -$ number of customers to be assigned a lock box

\item[]  $n -$ number of potential lock box sites

\item[]  $c_{ij} -$ annual cost of capital associated with serving customer $j$ from lock box $i$ 

\item[]  $f_{i} -$  annual fixed cost of operating a lock box at location $i$
\end{itemize}

\noindent {\bf Variables:}
\begin{itemize}

\item[]  $x_{ij} - $ a binary variable which is equal to 1 if customer $j$ is assigned to lock box $i$
and 0 if not

\item[]  $y_{i} - $ a binary variable which is equal to 1 if the lock box at location $i$ is opened and 0 if
not

\end{itemize}
The   integer linear program  for the lock box location problem is
$$
\eqnarrayx{
  & \min  &\sum_{i = 1}^{n} \sum_{j = 1}^{m} c_{ij} x_{ij}& + &\sum_{i = 1}^{n} f_{i} y_{i} &&&&&
\eq{eq:lockobj} \cr
(LB) &&x_{ij} - y_{i} &\le& 0, & i = 1, \ldots, n, & j = 1, \ldots, m
&&&\eq{eq:locksetup} \cr  &{\rm s.t.} & \sum_{i = 1}^{n} x_{ij} &=& 1, & j = 1, \ldots, m &&&&\eq{eq:lockdemand} \cr
&& x_{ij}, \, \, y_{i} &\in& \{ 0, 1 \}, & i = 1, \ldots, n, & j = 1, \ldots, m. &&&\eq{eq:lockbinary}
\cr
}
$$

The objective (\ref{eq:lockobj}) is to minimize the sum of the cost of capital plus the fixed cost of
operating the lock boxes.   Constraints (\ref{eq:locksetup})  are forcing 
constraints and require that a lock box be open if a customer is served by that
lock box. For now, we consider these the $A^{\prime} x \ge b^{\prime}$
constraints.  The requirement that every customer be assigned a lock box is
modeled by constraints (\ref{eq:lockdemand}).  For now, we consider these the
$A^{\prime \prime} x \ge b^{\prime \prime}$ constraints.

\vskip 12pt
{\bf Location Example 1:} A three plant, five customer model.

\vskip 8pt

\begin{table}[ht]
\centering
\vskip 8pt
\begin{tabular}{|cc|c|c|} \hline
       &    & CUSTOMER &         \\
      &     &\begin{tabular}{ccccc}
             1&2&3&4&5 \end{tabular} & FIXED COSTS  \\ \hline
     &   1   &\begin{tabular}{ccccc}
             2&3&4&5&7 \end{tabular} &   2  \\
 PLANT & 2   &\begin{tabular}{ccccc}
             4  &  3  &  1  &  2  &  6 \end{tabular} &  3  \\    
       & 3   &\begin{tabular}{ccccc}
            5   &  4  &  2  &  1  &  3 \end{tabular} &  3  \\   \hline
\end{tabular}  
\caption{Data for a 3 plant, 5 customer problem} 
\label{table:spl3by5data}  
\end{table}  
  

\vskip 10pt
\begin{eqnarray*}
\min  && 2x_{11} +3 x_{12} + 4x_{13} + 5x_{14}+ 7x_{15} + 2 y_{1} + \\
&& 4x_{21} +3 x_{22} + x_{23} + 2x_{24}+  6x_{25} + 3y_{2}+ \\
&& 5x_{31} +4 x_{32} + 2 x_{33} + x_{34}+  3x_{35} +   3y_{3} \\
\end{eqnarray*}


\begin{eqnarray*}
\begin{array}{lll}
x_{11}\leq y_{1}\leq 1 & &  \\
x_{12}\leq y_{1}\leq 1 & & \\
x_{13}\leq y_{1}\leq 1 & & \\
x_{14}\leq y_{1}\leq 1 & & \\
x_{15}\leq y_{1}\leq 1 & & \\
x_{21}\leq y_{2}\leq 1 & & \\
x_{22}\leq y_{2}\leq 1 & &   \\
x_{23}\leq y_{2}\leq 1 & & \\
x_{24}\leq y_{2}\leq 1 & & \\
x_{25}\leq y_{2}\leq 1 & & \\
x_{31}\leq y_{3}\leq 1 & & \\
x_{32}\leq y_{3}\leq 1 & &\\
x_{33}\leq y_{3}\leq 1 & &\\ 
x_{33}\leq y_{3}\leq 1 & &\\ 
x_{33}\leq y_{3}\leq 1 & &\\ 
\end{array}
 A^{\prime }x \ge b^{\prime} \,\, {\rm constraints} \\
x_{ij},y_{i}\ge 0 , \,\, i = 1, \ldots, n, \, \, j = 1, \ldots, m.   
\end{eqnarray*}

 
\[
\begin{array}{llll}
{\rm s.t.} &x_{11}+x_{21}+x_{31}  = 1 & & \\
&x_{12}+x_{22}+x_{32} = 1 & &   \\
&x_{13}+x_{23}+x_{33} = 1 & &  \\
&x_{14}+x_{24}+x_{34} = 1 & &  \\
&x_{15}+x_{25}+x_{35} = 1 & &  
\end{array}   A^{\prime \prime}   x \ge b^{\prime \prime} \,\, {\rm
constraints}
\]
  
  


                      


\vskip 12pt

{\bf Location Example 2 (SPL2):} A three plant, three customer model.

\vskip 8pt


\begin{table}[ht]
\centering
\begin{tabular}{|cc|c|c|} \hline
       &    & CUSTOMER &         \\
      &     &\begin{tabular}{ccc}
             1&2&3 
             \end{tabular} & FIXED COSTS  \\ \hline
     &   1   &\begin{tabular}{ccc}
             2&1&1 
             \end{tabular} &   1  \\
 PLANT & 2   &\begin{tabular}{ccc}
             1  &  2  &  1   
             \end{tabular} &  1  \\    
       & 3   &\begin{tabular}{ccc}
            1   &  1  &  2   
            \end{tabular} &  1  \\   \hline
\end{tabular} 
\caption{Data for a three plant, three customer problem} 
\label{table:spl3by3data}   
\end{table}  

  
\vskip 8pt
\begin{eqnarray*}
\min  && 2x_{11} + x_{12} + x_{13}  +  y_{1} + \\
&& x_{21} +2 x_{22} + x_{23} +       y_{2}+ \\
&& x_{31} + x_{32} + 1 x_{33} +  +       y_{3} \\
\end{eqnarray*}


  
\begin{eqnarray*}
\begin{array}{lll}
x_{11}\leq y_{1}\leq 1 & &  \\
x_{12}\leq y_{1}\leq 1 & & \\
x_{13}\leq y_{1}\leq 1 & & \\
x_{21}\leq y_{2}\leq 1 & & \\
x_{22}\leq y_{2}\leq 1 & &   \\
x_{23}\leq y_{2}\leq 1 & & \\
x_{31}\leq y_{3}\leq 1 & & \\
x_{32}\leq y_{3}\leq 1 & &\\
x_{33}\leq y_{3}\leq 1 & &\\ 
\end{array}
A^{\prime}   x \ge b^{\prime} \,\, {\rm
constraints} \\
x_{ij},y_{i}\ge 0 , \,\, i = 1, \ldots, n, \, \, j = 1, \ldots, m.   
\end{eqnarray*}

\[
\begin{array}{llll}
{\rm s.t.} &x_{11}+x_{21}+x_{31} = 1 & & \\
&x_{12}+x_{22}+x_{32} = 1 & &   \\
&x_{13}+x_{23}+x_{33} = 1 & &
\end{array}  A^{\prime \prime}   x \ge b^{\prime \prime} \,\, {\rm
constraints}
  \]
  







\subsubsection{Generalized Assignment Problem Example}\label{section:genass}

A problem that plays a prominent role in
vehicle routing is the {\it generalized assignment problem.}    The problem is to assign each of $n$
tasks to $m$ servers without exceeding the resource capacity of the servers.

\noindent{\bf Parameters:}
\begin{itemize}
\item[]  $n -$ number of required tasks
\item[]  $m -$   number of servers
\item[]  $f_{ij} -$ cost of assigning task $i$ to server $j$
\item[]  $b_{j} -$  units of resource available to server $j$
\item[]  $a_{ij} -$ units of server $j$ resource required to perform task $i$
\end{itemize}

\noindent{\bf Variables:}
\begin{itemize}
\item[]  $x_{ij} -$ a binary variable which is equal to 1 if task $i$ is assigned to server $j$
and 0 if not
\end{itemize}
The integer linear program for the generalized assignment problem  is 
$$
\eqnarrayx{
&  \min &\sum_{i = 1}^{n} \sum_{j = 1}^{m} f_{ij} x_{ij} &&&&&&& \eq{eq:gapobj} \cr
(GAP) &{\rm s.t.}& \sum_{j = 1}^{m} x_{ij} &=& 1, & i = 1, \ldots, n  &&&& \eq{eq:gapassign} \cr
&& \sum_{i = 1}^{n} a_{ij} x_{ij} &\le& b_{j}, &j = 1, \ldots, m  &&&&\eq{eq:gapcapacity}  \cr
&& x_{ij} &\in& \{ 0, 1 \}, & i = 1, \ldots, n, & j = 1, \ldots, m.  &&&
\eq{eq:gapbinary}  \cr
}
$$

The objective function (\ref{eq:gapobj}) is to minimize the total assignment cost.  Constraint
(\ref{eq:gapassign}) requires that each task is assigned a server.  These
constraints correspond to the $A^{\prime \prime} x \ge b^{\prime \prime}$
constraints.   The requirement that the server capacity not be exceeded is given
in (\ref{eq:gapcapacity}). These corresspond to the $A^{\prime} x \ge
b^{\prime}$ constraints that are used to define ${\cal P}$. The test problem
used in the file {\tt genAssign.osil} is:


 
\begin{eqnarray*}
{\rm min} \quad 2 x_{11} + 11 x_{12} + 7 x_{21} + 7 x_{22} && \\
+ 20 x_{31} + 2 x_{32} + 5 x_{41} + 5x_{42} && \\
x_{11} + x_{12}  &=&    1  \\
x_{21} + x_{22}  &=&    1 \\
x_{31} + x_{32} &=&    1 \\
x_{41} + x_{42} &=&    1 \\
3 x_{11} + 6 x_{21} + 5 x_{31} + 7 x_{41} &\le&   13 \\
2 x_{12} + 4 x_{22} + 10 x_{32} + 4 x_{42} &\le&   10
\end{eqnarray*}
 

\subsubsection{Defining the Problem Instance and Blocks}\label{section:defineinstance}

Here we describe how to use the OSoption stuff and OSInstance.  We illustrate
with a simple plant location problem. Refer back to the example in Table
\ref{table:spl3by5data} for a three-plant, five-customer problem. We treat the
fixed charge constraints as the block constraints, i.e. we treat constraint set
\ref{eq:locksetup} as the set $A^{\prime} x \ge b^{\prime}$ constraints. These
constraints naturally break into a block for each plant, i.e. there is a block
of constraints:
\begin{eqnarray}
x_{ij} \le y_{i}
\end{eqnarray}
In order to use the OS Dip solver it is necessary to: 1) define the set of
variables in each block and 2) define the set of constraints that constitute the
core or coupling constraints. This information is communicated to the OS Dip
solver using Optimization Services option Language (OSoL). The OSoL input file
for the example in  Table \ref{table:spl3by5data} appears in Figures
\ref{figure:parinc-osil} and \ref{figure:parinc-osil2}.  See lines 32-55. There
is an {\tt <other>} option with {\tt name="variableBlockSet"} for each block.
Each block then lists the variables in the block. For example, the first block
consists of variable indexed by 0, 1, 2, 3, 4, and 15. These correspond to
variables $x_{11},$  $x_{12},$  $x_{13},$  $x_{13},$ $x_{14},$ and  $y_{1}.$
Likewise the second block corresponds to the variable for the second plant and
the third block corresponds to variables for the third plant.


  

{\small
\begin{figure}[hp]
   \small {\obeyspaces\let =\
\makebox[0in][t]{\fbox{\tt\begin{tabular}{@{}l@{}}
1   <?xml version="1.0" encoding="UTF-8"?>\\
2   <osol>\\
3      <general>\\
4         <instanceName>spl1 -- setup constraints are the blocks</instanceName>\\
5      </general>\\
6      <optimization>\\
7         <variables numberOfOtherVariableOptions="6">\\
8            <other name="initialCol" solver="Dip" numberOfVar="6" value="0">\\
9               <var idx="0" value="1"/>\\
10              <var idx="1" value="1"/>\\
11              <var idx="2" value="1"/>\\
12              <var idx="3" value="1"/>\\
13              <var idx="4" value="1"/>\\
14              <var idx="15" value="1"/>\\
15           </other>\\
16           <other name="initialCol" solver="Dip" numberOfVar="6" value="1">\\
17              <var idx="5" value="1"/>\\
18              <var idx="6" value="1"/>\\
19              <var idx="7" value="1"/>\\
20              <var idx="8" value="1"/>\\
21              <var idx="9" value="1"/>\\
22              <var idx="16" value="1"/>\\
23           </other>\\
24           <other name="initialCol" solver="Dip" numberOfVar="6" value="2">\\
25              <var idx="10" value="1"/>\\
26              <var idx="11" value="1"/>\\
27              <var idx="12" value="1"/>\\
28              <var idx="13" value="1"/>\\
29              <var idx="14" value="1"/>\\
30              <var idx="17" value="1"/>\\
31           </other>\\
32           <other name="variableBlockSet" solver="Dip" numberOfVar="6" value="MySolver1">\\
33              <var idx="0"/>\\
34              <var idx="1"/>\\
35              <var idx="2"/>\\
36              <var idx="3"/>\\
37              <var idx="4"/>\\
38              <var idx="15"/>\\
39           </other>\\
40           <other name="variableBlockSet" solver="Dip" numberOfVar="6" value="MySolver2">\\
41              <var idx="5"/>\\
42              <var idx="6"/>\\
43              <var idx="7"/>\\
44              <var idx="8"/>\\
45              <var idx="9"/>\\
46              <var idx="16"/>\\
47           </other>\\
\end{tabular} }}} \medskip
\caption{A sample OSoL file -- SPL1.osol}\label{figure:parinc-osil}
\end{figure}
} %end small


It is also necessary to convey which constraints constitute the core
constraints. This is done in lines 58-64. The core constraints are indexed by
15, 16, 17, 18, 19. These constitute the demand constraints given in Equation
(\ref{eq:lockdemand}). 


Notice also that in lines 32, 40, and 48 there is an attribute {\tt value} in
the {\tt <other>} variable element with the attribute {\tt name} equal to {\tt
variableBlockSet}.  The attribute {\tt value} should be the name of the solver
factory that should be assigned to solve that block. For example, if the
optimization problem that results from solving a linear objective over the
constraints defining the first block is solved using {\tt MySolver1} then this
must correspond to a 

\begin{verbatim}
OSDipBlockSolverFactory::factories["MySolver1"] = new
MySolver1::Factory;
\end{verbatim}  

in the file {\bf OSDipFactoryInitializer.h}.  In the test file, {\tt spl1.osol}
for the first block we set the solver to a specialized solver for the simple
plant location problem ({\tt OSDipBlockSplSolver}) and for the other two blocks
we use the generic solver ({\tt OSDipBlockCoinSolver}).




{\small
\begin{figure}[hp]
   \small {\obeyspaces\let =\
\makebox[0in][t]{\fbox{\tt\begin{tabular}{@{}l@{}}
48           <other name="variableBlockSet" solver="Dip" numberOfVar="6" value="MySolver3">\\
49              <var idx="10"/>\\
50              <var idx="11"/>\\
51              <var idx="12"/>\\
52              <var idx="13"/>\\
53              <var idx="14"/>\\
54              <var idx="17"/>\\
55           </other>\\
56        </variables>\\
57        <constraints numberOfOtherConstraintOptions="1">\\
58           <other name="constraintSet" solver="Dip" numberOfCon="5" type="Core">\\
59              <con idx="15"/>\\
60              <con idx="16"/>\\
61              <con idx="17"/>\\
62              <con idx="18"/>\\
63              <con idx="19"/>\\
64           </other>\\
65        </constraints>\\
66     </optimization>\\
67  </osol>\\
\end{tabular} }}} \medskip
\caption{A sample OSoL file -- SPL1.osol (Continued)}\label{figure:parinc-osil2}
\end{figure}
} %end small
 
One can use the OSoL file to specify a set of starting columns for the initial
restricted master. In Figure \ref{figure:parinc-osil} see lines 8-31.  In and OS
option file (OSoL) there is {\tt <variables>} element that has {\tt <other>}
children. Initial columns are specified using the {\tt <other>} elements. This
is done by using  the {\tt name} attribute and setting its value to {\tt
initialCol}. Then the children of the tag contain index-value pairs that specify
the column. For example, the first initial column corresponds to setting:

\begin{eqnarray*}
x_{11} = 1, \quad  x_{12} = 1, \quad  x_{13} = 1, \quad  x_{14} = 1, \quad
x_{15} = 1, \quad y_{1} = 1
\end{eqnarray*}


Finally note that in all of this discussion we know to apply the options to {\bf
Dip} because the attribute {\tt solver} always had value {\tt Dip}. It is
critical to set this attribute in all of the option tags. 


\subsubsection{The Dip Parameter File}\label{section:paramaterfile}

The {\bf Dip} solver has a utility class {\bf UtilParameters},  for parsing
a parameter file. The {\bf UtilParameters} class constructor takes a parameter
file as an argument. In the case of the OS Dip solver the name of the parameter
file is {\bf osdip.parm} and the parameter is read in at the command line with
the command

\begin{verbatim}
./osdip -param osdip.parm
\end{verbatim}

The {\bf UtilParameters} class has a method {\bf GetSetting()} for reading the
paramater values. In the OS Dip implementation there is a class {\bf OSDipParam}
that has a data memmbers key paramaters such as the name of the input OSiL file
and input OSoL file. The {\bf OSDipParam} class has a method
{\bf getSettings()} that takes as an argument a pointer to an object in the {\bf
UtilParameters} and uses {\bf GetSetting()} method to return the relevant
paramater values. For example:

\begin{verbatim}
OSiLFile = utilParam.GetSetting("OSiLFile", "", common); 
OSoLFile = utilParam.GetSetting("OSoLFile", "", common);
\end{verbatim}

In the current {\bf osdip.parm} file we have:

\begin{verbatim}

#first simple plant location problem
OSiLFile = spl1.osil
#setup constraints as blocks
OSoLFile = spl1.osol
#assignment constraints as blocks
#OSoLFile = spl1-b.osol

#second simple plant location problem
#OSiLFile = spl2.osil
#setup constraints as blocks
#OSoLFile = spl2.osol
#assignment constraints as blocks
#OSoLFile = spl2-b.osol

#third simple plant location problem -- block matrix data not used
#OSiLFile = spl3.osil
#setup constraints as blocks
#OSoLFile = spl3.osol

#generalized assignment problem
#OSiLFile = genAssign.osil
#OSoLFile = genAssign.osol

#Martin textbook example
#OSiLFile = smallIPBook.osil
#OSoLFile = smallIPBook.osol
\end{verbatim}
 
By commenting and uncommenting you can run one of four problems that are in the
{\bf data} directory. The first example, {\bf spl1.osil}, corresponds to the
simple plant location model given in Table \ref{table:spl3by5data}. Using the
option file {\bf spl1.osol} treats the setup forcing constraints
\ref{eq:locksetup} as the $A^{\prime} x \ge b^{\prime}$ constraints. Using the
option file {\bf spl1-b.osol} treats the demand constraints
\ref{eq:lockdemand} as the $A^{\prime} x \ge b^{\prime}$ constraints. Likewise
for the problem {\bf spl2.osil} which correponds to the simple plant location
data given in Table \ref{table:spl3by3data}.

In both examples {\bf spl1.osil} and {\bf spl2.osil} the $A^{\prime} x \ge
b^{\prime}$ constraints are explicitly represented in the OSiL file. However,
this is not necessary. The solver Factory {\bf OSDipBlockSlpSolver} is a special
oracle that only needs the objective function coefficients and pegs variables
based on the sign of the objective function coefficients. The {\bf spl3.osil} is
the example given in Table \ref{table:spl3by5data} but without the setup forcing
constraints. Each block uses the {\bf OSDipBlockSlpSolver} oracle. 

The {\bf genAssign.osil} file corresponds to the generalized assignment problem
given in Section \ref{section:genass}.  The option file {\bf genAssign.osol} 
treats the capacity constraints \ref{eq:gapcapacity} as the $A^{\prime} x \ge
b^{\prime}$ constraints. 

The last problem defined in the file {\bf smallIPBook.osil} is based on Example
16.3 on page 567 in {\it Large Scale Linear and Integer Optimization}.  The
option file treats the constraints
$$
4x_{1} + 9 x_{2} \le 18, \quad -2x_{1} + 4 x_{2} \le 4
$$
as the $A^{\prime} x \ge b^{\prime}$ constraints.

The user should also be aware of the parameter {\tt solverFactory}. This
parameter is the name of the default solver Factory. If a solver is not named
for a block in the OSoL file this value is used. We have set the value of this
string to be {\tt OSDipBlockCoinSolver}.


   


\subsubsection{Issues to Fix}

\begin{itemize}
  \item Enhance solveRelaxed to allow parallel processing of blocks. See ticket
  30.
  \item Does not work when there are 0 integer variables. See ticket 31.
  
  \item Be able to set options in C++ code. See ticket 41.  It would be nice to
  be able to read all the options from a generic options file. It seems like
  right now options for the {\bf DecompAlgo } class cannot be set inside C++.
  
  \item Problem with Alps  bounds at node 0. See ticket 43
  
  \item Figure out how to use BranchEnforceInMaster or BranchEnforceInSubProb so
  I don't get the large bonds on the variables. See ticket 47.
\end{itemize}



\subsubsection{Miscellaneous Issues}
 
 If you want to terminate at the root node and just get the dual value under the {\tt ALPS } option put:
 
\begin{verbatim}
[ALPS]
nodeLimit = 1
\end{verbatim}

More from Matt:



\begin{verbatim}
Kipp - the example you sent finds the optimal solution after a few passes of pricing and therefore never calls the cut generator. By default, the PC solver, in the root node starts with pricing, and does not stop until it prices out (or finds optimal, or within gap limits).

If it prices out and has not yet found optimal, then it will proceed to cuts.

This is parameter driven.


You'll see in the log file (LogDebugLevel = 3),
PRICE_AND_CUT  LimitRoundCutIters       2147483647
PRICE_AND_CUT  LimitRoundPriceIters     2147483647

This is the number of Price/Cut iterations to take before switching off (i.e., MAXINT).

To force it to cut before pricing out, change this parameter in the parm file. For example, if you change to :

[DECOMP]
LimitRoundPriceIters = 1
LimitRoundCutIters   = 1

It will then go into your generateCuts after one pricing iteration.

\vskip 12pt

If there is an integer solution at the root node, it may be the case that we are still not optimal. A perfect example is where you want to add tour-breaking constraints. There could be an integer solution, but you still violate a tour-breaking constraint. Here is what Matt says:
``By default, DIP assumes, that if problem is LP feasible to the linear system and IP feasible, then it is feasible. In the case where the user knows something that DIP does not (e.g., that the linear system does not define the entire valid constraint system, as in TSP), then they must provide a derivation of this function APPisUserFeasible. Then, DIP will check LP feasible, IP feasible and lastly, APPisUserFeasible before declaring a point a feasible solution.''

For an example of using this see, \url{https://projects.coin-or.org/Dip/browser/trunk/Dip/examples/TSP/TSP_DecompApp.cpp}.

\end{verbatim}
